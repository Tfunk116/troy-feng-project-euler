/* -------- SOLVED -------- */

/* The sequence of triangle numbers is generated by adding the natural numbers. So the N'th triangle number 
 * would be 1 + 2 + ... + N. The first ten terms would be:
 * 
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * 
 * Let us list the factors of the first seven triangle numbers:
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3
 * 10: 1,2,5
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 * 
 * We can see that 28 is the first triangle number to have over five divisors.
 * 
 * What is the value of the first triangle number to have over N divisors? 
 * 
 * INPUT: 1 <= T <= 10, 1 <= N <= 10^3 */

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Euler012 {
	
	/* Notes/approach: 
	 * 		k'th triangular number is k(k+1)/2.
	 * 		We're looking for number of DIVISORS, not factors.
	 * 		If we prime factorize, #factors is prod of each exponent+1.
	 * 		k and k+1 are relatively prime, and do not share any factors other than 1.
	 * 		So k/2 and k+1 (or (k+1)/2 and k if k odd) must be relatively prime too.
	 * 		So #factors[k(k+1)/2] = #factors[k/2 or k] * #factors[k+1 or (k+1)/2]. 
	 * 
	 * Definitely some sort of DP, right? 
	 * HashMap stores #factors of all integers? */
	
	/* Modified sieve s.t. primes[i] contains the smallest prime that divides i. */
	static long[] primes;
	
	/* Store (k,v), where v is number of factors k'th triangular number has. Some memoization :) */
	static Map<Integer,Integer> table;
	
	/* Returns num factors of k*(k+1)/2. */
	public static int numFactors(int k) {
		if (k == 1) return 1;
		if (table.containsKey(k)) return table.get(k);
		int[] exponents = new int[k+2];
		int factor;
		int n1 = k;
		while (n1 != 1) {
			factor = (int) primes[n1];
			exponents[factor]++;
			n1 /= factor;
		}
		int n2 = k+1;
		while (n2 != 1) {
			factor = (int) primes[n2];
			exponents[factor]++;
			n2 /= factor;
		}
		exponents[2]--;
		
		int ans = 1;
		if (exponents[2] > 0) ans *= (exponents[2]+1);
		if (exponents[3] > 0) ans *= (exponents[3]+1);
		for (int i = 5; i < exponents.length; i+=6) {
			if (exponents[i] > 0) ans *= (exponents[i]+1);
			if (i+2 < exponents.length && exponents[i+2] > 0) ans *= (exponents[i+2]+1);
		}
		table.put(k,ans);
		return ans;
	}
	
	public static void main(String[] args) {
		table = new HashMap<Integer,Integer>();
		/* Sieve and fill primes. */
		primes = new long[100001];
		for (int i = 2; i < primes.length; i++) {
			if (primes[i] == 0) {
				primes[i] = i;
				for (int j = i*i; j < primes.length && j > 0; j+= i)
					primes[j] = i;
			}
		}
		Scanner s = new Scanner(System.in);
		int t = Integer.parseInt(s.nextLine());
		for (int i = 0; i < t; i++) {
			int n = Integer.parseInt(s.nextLine());
			int k = 1;
			while (numFactors(k) <= n) {
				k++;
			}
			System.out.println((long) k * ((long) k+1) / 2);
		}
		s.close();
	}
}
