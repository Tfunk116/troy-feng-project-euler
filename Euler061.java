/* -------- UNSOLVED -------- */

/* Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) 
 * numbers and are generated by the following formulae:
 *
 *		Triangle 		T_n = n*(n+1)/2 	1,3,6,10,15,...
 *		Square 			S_n = n^2			1,4,9,16,25,...
 *		Pentagon 		P_n = n*(3n-1)/2	1,5,12,22,35,...
 *		Hexagon 		Hex_n = n*(2n-1)	1,6,15,28,45,...
 *		Heptagon 		Hep_n = n*(5n-3)/2 	1,7,18,34,55,...
 *		Octagon 		O_n = n*(3n-2)		1,8,21,40,65,...
 *
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties:
 *		1. The set is cyclic, in that the last two digits of each number is the first two digits of the next
 *		   number (including the last number with the first).
 *		2. Each polygonal type: triangle (T_127 = 8128), square (S_91 = 8281), and pentagonal (P_44 = 2882), 
 * 		   is represented by a different number in the set.
 *		3. This is the only set of 4-digit numbers with this property.
 *
 * You are given a set of numbers N \in {3,4,5,6,7,8}. Find the sum of 4-digit numbers from N-gonal sets that 
 * respect the above property. If there are multiple such numbers print their sums in sorted order. 
 *
 * INPUTS: 3 <= T <= 6, then T numbers N space separated 3 <= N <= 8. 
 * Sample: input T=3, then N=3,4,5 --> output 19291 */

import java.util.Scanner;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

public class Euler061 {
	
	/* Thoughts/approach: We are looking for sets of T numbers, without ANY duplicates it seems, that belong
	 * to N-gonal sets specified by a set of T total Ns. We need only check 4-digit N-gonal numbers. i.e. we
	 * need to find T distinct 4-digit figurate numbers, aligning with the given set of T Ns, that are cyclic 
	 * (by 2 digits). I think the Ns are all distinct. For N={3,4,5}, say we loop over 4-digit T_n and arrive
	 * at 8128. To get a cyclic square number, we need a square that begins with 28. So I'm thinking we can
	 * keep HashMaps, mapping from key \in [10,99] to val \in [1000,9999], where map.get(key) returns a four
	 * digit number that is figurate and has first two digits equal to key. These HashMaps can be
	 * pre-calculated. Then, given a set of N say {3,4,5}, we would loop through all 4-digit T_n and search
	 * for T_n % 100 in the S_n and P_n HashMaps. 
	 *
	 * Using basic algebra, the terms of each figurate sequence between 1000 and 9999 fall in range:
	 * T: n=45 to 140
	 * S: n=32 to 99
	 * P: n=26 to 81
	 * Hex: n=23 to 70
	 * Hep: n=21 to 63
	 * O: n=19 to 58 */

	/* Each of the following HashMaps contains two-digit keys. map.get(key) holds the four-digit figurate
	 * number(s) whose first two digits are equal to key. */
	static Map<Integer,Integer> tri;
	static Map<Integer,Integer> square;
	static Map<Integer,Integer> pent;
	static Map<Integer,Integer> hex;
	static Map<Integer,Integer> hep;
	static Map<Integer,Integer> oct;

	/* Fill all the HashMaps with figurate numbers from 1000 to 9999. */
	public static void fillMaps() {
		tri = new HashMap<Integer,Integer>();
		square = new HashMap<Integer,Integer>();
		pent = new HashMap<Integer,Integer>();
		hex = new HashMap<Integer,Integer>();
		hep = new HashMap<Integer,Integer>();
		oct = new HashMap<Integer,Integer>();
		for (int n = 45; n <= 140; n++) {
			int x = n*(n+1)/2;
			tri.put(x/100, x);
		}
		for (int n = 32; n <= 99; n++) {
			int x = n*n;
			square.put(x/100, x);
		}
		for (int n = 26; n <= 81; n++) {
			int x = n*(3*n-1)/2;
			pent.put(x/100, x);
		}
		for (int n = 23; n <= 70; n++) {
			int x = n*(2*n-1);
			hex.put(x/100, x);
		}
		for (int n = 21; n <= 63; n++) {
			int x = n*(5*n-3)/2;
			hep.put(x/100, x);
		}
		for (int n = 19; n <= 58; n++) {
			int x = n*(3*n-2);
			oct.put(x/100, x);
		}
	}

	public static boolean alreadyUsed(int[] used, int next) {
		for (int i = 0; i < used.length && used[i] != 0; i++) {
			if (used[i]==next) return true;
		}
		return false;
	}

	/* Return next lexicographic permutation of p[]. */
	public static boolean nextPermutation(int[] p) {
		int n = p.length;
		int k = n-2;
		while (k >= 0 && p[k] > p[k+1]) k--;
		if (k < 0) return false;
		int l = n-1;
		while (p[l] < p[k]) l--;
		int temp = p[l];
		p[l] = p[k];
		p[k] = temp;
		for (int i = k+1; i <= (n+k)/2; i++) {
			temp = p[n-i+k];
			p[n-i+k] = p[i];
			p[i] = temp;
		}
		return true;
	}

	/* Recursive function finding sets of cyclic N-gonal numbers corresponding to given set of N. */
	public static void findCyclic(int[] N, int cur, int[] usedSoFar, int sumSoFar, Set<Integer> ans) {
		if (cur==N.length) {
			for (int i: usedSoFar) System.out.print(i + " ");
			System.out.println();
			/* Check that last and first elements are cyclic. */
			if (usedSoFar[cur-1]%100 != usedSoFar[0]/100) return;
			System.out.println("FOUND");
			ans.add(sumSoFar);
			return;
		}
		int n = N[cur];
		int lastUsed = usedSoFar[cur-1];
		int key = lastUsed%100;
		//System.out.println(key);
		if (n==3) {
			if (tri.containsKey(key)) {
				int next = tri.get(key);
				if (!alreadyUsed(usedSoFar,next)) {
					usedSoFar[cur] = next;
					findCyclic(N,cur+1,usedSoFar,sumSoFar+next,ans);
				}
			}
			return;
		}
		if (n==4) {
			if (square.containsKey(key)) {
				int next = square.get(key);
				if (!alreadyUsed(usedSoFar,next)) {
					usedSoFar[cur] = next;
					findCyclic(N,cur+1,usedSoFar,sumSoFar+next,ans);
				}
			}
			return;
		}
		if (n==5) {
			if (pent.containsKey(key)) {
				int next = pent.get(key);
				if (!alreadyUsed(usedSoFar,next)) {
					usedSoFar[cur] = next;
					findCyclic(N,cur+1,usedSoFar,sumSoFar+next,ans);
				}
			}
			return;
		}
		if (n==6) {
			if (hex.containsKey(key)) {
				int next = hex.get(key);
				if (!alreadyUsed(usedSoFar,next)) {
					usedSoFar[cur] = next;
					findCyclic(N,cur+1,usedSoFar,sumSoFar+next,ans);
				}
			}
			return;
		}
		if (n==7) {
			if (hep.containsKey(key)) {
				int next = hep.get(key);
				if (!alreadyUsed(usedSoFar,next)) {
					usedSoFar[cur] = next;
					findCyclic(N,cur+1,usedSoFar,sumSoFar+next,ans);
				}
			}
			return;
		}
		if (n==8) {
			if (oct.containsKey(key)) {
				int next = oct.get(key);
				if (!alreadyUsed(usedSoFar,next)) {
					usedSoFar[cur] = next;
					findCyclic(N,cur+1,usedSoFar,sumSoFar+next,ans);
				}
			}
			return;
		}
	}

	public static void getPermSolution(int[] N, Set<Integer> ans) {
		int n = N[0];
		int[] usedSoFar = new int[N.length];
		if (n==3) {
			for (int i = 45; i <= 140; i++) {
				usedSoFar[0] = i*(i+1)/2;
				findCyclic(N,1,usedSoFar,usedSoFar[0],ans);
			}
		}
		else if (n==4) {
			for (int i = 32; i <= 99; i++) {
				usedSoFar[0] = i*i;
				findCyclic(N,1,usedSoFar,usedSoFar[0],ans);
			}
		}
		else if (n==5) {
			for (int i = 26; i <= 81; i++) {
				usedSoFar[0] = i*(3*i-1)/2;
				findCyclic(N,1,usedSoFar,usedSoFar[0],ans);
			}
		}
		else if (n==6) {
			for (int i = 23; i <= 70; i++) {
				usedSoFar[0] = i*(2*i-1);
				findCyclic(N,1,usedSoFar,usedSoFar[0],ans);
			}
		}
		else if (n==7) {
			for (int i = 21; i <= 63; i++) {
				usedSoFar[0] = i*(5*i-3)/2;
				findCyclic(N,1,usedSoFar,usedSoFar[0],ans);
			}
		}
		else if (n==6) {
			for (int i = 19; i <= 58; i++) {
				usedSoFar[0] = i*(3*i-2);
				findCyclic(N,1,usedSoFar,usedSoFar[0],ans);
			}
		}
	}

	public static Set<Integer> solution(int[] N) {
		Set<Integer> ans = new HashSet<Integer>();
		getPermSolution(N, ans);
		while (nextPermutation(N)) {
			for (int i: N) System.out.print(i + " ");
			System.out.println();
			getPermSolution(N, ans);
		}
		return ans;
	}

	/* Insert x into n, a la insertion sort. */
	public static void insert(int x, int[] n) {
		int k = 0;
		while (k < n.length && x >= n[k] && n[k] != 0) k++;
		int temp = n[k];
		n[k] = x;
		for (int i = k+1; i < n.length-1 && temp != 0; i++) {
			n[i+1] = n[i];
			n[i] = temp;
			temp = n[i+1];
		}
	}
	
	public static void main(String[] args) {
		fillMaps();
		Scanner s = new Scanner(System.in);
		int T = Integer.parseInt(s.nextLine());
		String[] NInputs = s.nextLine().split(" ");
		int[] N = new int[T];
		for (int i = 0; i < T; i++) {
			int next = Integer.parseInt(NInputs[i]);
			insert(next, N);
		}
		for (int i: N) System.out.print(i + " ");
		System.out.println();

		List<Integer> ans = new ArrayList<Integer>(solution(N));
		Collections.sort(ans);
		ans.forEach((n)->System.out.println(n));
		s.close();
	}
}
