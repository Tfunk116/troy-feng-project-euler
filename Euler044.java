/* -------- SOLVED -------- */

/* Pentagonal numbers are generated by the formula, P_n = n*(3n-1)/2. The first ten pentagonal numbers are:
 * 
 * 1,5,12,22,35,51,70,92,117,145,...
 * 
 * It can be seen that P_4 + P_7 = 22 + 70 = 92 = P_8. Also P_7 - P_5 = 70 - 35 = 35 = P_5 which is also 
 * pentagonal.
 * 
 * Generalizing for a given K find all P_n, where n < N, such that P_n - P_{n-k} is pentagonal OR
 * P_n + P_{n-k} is pentagonal.
 * 
 * INPUTS: 1 <= K <= 9999, K+1 <= N <= 10^6, space-separated N and K */

import java.util.Scanner;

public class Euler044 {
	
	/* Thoughts/approach: Could precalculate and memoize all pentagonal numbers (since N <= 10^6). But since
	 * only one N/K pair is tested at a time, we don't need the extra storage. Checking if a number is
	 * pentagonal is pretty much O(1). */
	
	/* We want to check if there exists a natural number n s.t. n(3n-1)/2 = p. Since this is a quadratic in n,
	 * we can plug stuff into the quadratic formula to show that n = (1 \pm \sqrt(1+24p)) / 6 must satisfy this 
	 * quadratic. As n > 0, we need only consider whether (1+\sqrt(1+24p)) / 6 is a natural number, which is
	 * iff 1+24p is a perfect square and 1+\sqrt(1+24p) divides 6, which we can check in constant time. */
	public static boolean isPentagonal(long p) {
		long x = (long) Math.sqrt(1+24*p);
		return x*x == 1+24*p && (1+x)%6 == 0;
	}
	
	/* Returns n'th pentagonal number. */
	public static long pent(int n) {
		return (long) n * (3*n-1) / 2;
	}
	
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		String[] inputs = s.nextLine().split(" ");
		int N = Integer.parseInt(inputs[0]);
		int K = Integer.parseInt(inputs[1]);
		for (int n = K+1; n < N; n++) {
			long p1 = pent(n);
			long p2 = pent(n-K);
			if (isPentagonal(p1-p2) || isPentagonal(p1+p2)) System.out.println(p1);
		}
		s.close();
	}
}
